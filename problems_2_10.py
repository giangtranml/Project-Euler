def problem_11():

    grid = \
    """
        08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08
        49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00
        81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65
        52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91
        22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80
        24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50
        32 98 81 28 64 23 67 10 26 38 40 67 59 54 70 66 18 38 64 70
        67 26 20 68 02 62 12 20 95 63 94 39 63 08 40 91 66 49 94 21
        24 55 58 05 66 73 99 26 97 17 78 78 96 83 14 88 34 89 63 72
        21 36 23 09 75 00 76 44 20 45 35 14 00 61 33 97 34 31 33 95
        78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92
        16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57
        86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58
        19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40
        04 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66
        88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69
        04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36
        20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16
        20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54
        01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48
    """
    grid = grid.strip()
    grid = grid.split("\n")
    for i, g in enumerate(grid):
        grid[i] = list(path(int, g.strip().split(" ")))
    m = len(grid)
    n = len(grid[0])
    res = 0

    for i in range(m):
        for j in range(n):
            for direction in ((0, 1), (1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)):
                try:
                    product = 1
                    for k in range(4):
                        product *= grid[i + direction[0]*k][j + direction[1]*k]
                    res = max(res, product)
                except IndexError:
                    pass
    print(res)


def problem_12():
    """
        The sequence of triangle numbers is generated by adding the natural numbers.
            So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28.
            The first ten terms would be:

                1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

        Let us list the factors of the first seven triangle numbers:

             1: 1
             3: 1,3
             6: 1,2,3,6
            10: 1,2,5,10
            15: 1,3,5,15
            21: 1,3,7,21
            28: 1,2,4,7,14,28

        We can see that 28 is the first triangle number to have over five divisors.

        What is the value of the first triangle number to have over five hundred divisors?
    """
    pass


def problem_14():
    """
        The following iterative sequence is defined for the set of positive integers:

            n → n/2 (n is even)
            n → 3n + 1 (n is odd)

        Using the rule above and starting with 13, we generate the following sequence:

        13 → 40 → 20 → 10 → 5 → 16 → 8 → 4 → 2 → 1

        It can be seen that this sequence (starting at 13 and finishing at 1) contains 10 terms.
        Although it has not been proved yet (Collatz Problem), it is thought that all starting numbers finish at 1.

        Which starting number, under one million, produces the longest chain?

        NOTE: Once the chain starts the terms are allowed to go above one million.
    """
    MAX = int(1e6)
    res = 0
    max_length = 0
    for i in range(MAX-1, 2, -1):
        num = i
        chains = 0
        while num > 2:
            if num % 2 == 0:
                num //= 2
            else:
                num = num*3 + 1
            chains += 1

        print(chains)
        if max_length < chains:
            max_length = chains
            res = i
    print(res)

def problem_15():
    """
        Starting in the top left corner of a 2×2 grid,
        and only being able to move to the right and down,
        there are exactly 6 routes to the bottom right corner.

        How many such routes are there through a 20×20 grid?

        -------------------------------------------------------------------

        Dynamic Programming Approach:

        -------------------------
        | 2 | 3 | 4 | 5 | 6 | 7 |
        -------------------------
        | 3 | 6 | 10| 15| 21| 28|
        -------------------------
        | 4 | 10| 20| 35|   |   |
        -------------------------
        | 5 | 15| 35| 70|   |   |
        -------------------------
        | 6 |   |   |   |   |   |
        -------------------------
        | 7 |   |   |   |   |   |
        -------------------------

        This approach not only works for the square but also for the rectangle.

        --------------------------------------------------------------------
    """

    n = 20
    path = [[1]*n for _ in range(n)]
    for i in range(n):
        for j in range(n):
            if i == 0 and j > 0:
                path[i][j] = path[i][j-1] + 1
                continue
            if j == 0 and i > 0:
                path[i][j] = path[i-1][j] + 1
                continue
            path[i][j] = path[i-1][j] + path[i][j-1]

    for p in path:
        print(p)
    print(path[n-1][n-1])

def problem_16():
    num = 1 << 1000
    res = 0
    while num > 0:
        res += num % 10
        num //= 10

    print(res)

def problem_17():
    sample = """one, two, three, four, five, six, seven, eight, nine, ten
             eleven, twelve, thirteen, forteen, fifteen, sixteen, seventeen,
             eighteen, nineteen, twenty, thirty, forty,
             fifty, sixty, seventy, eighty, ninety
             hundred
             thousand"""
    1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 30
    40, 50,
